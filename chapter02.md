# 第2章 渲染流水线

渲染流水线的最终目的在于生成一张二维纹理，即在电脑屏幕上看到的所有效果。它的输入是一个虚拟摄像机、一些光源、一些shader以及纹理等。

## 2.1 综述

shader仅仅是渲染流水线中的一个环节。只有知道它在流水线中扮演怎样的角色，才能让shader发挥出作用。

### 2.1.1 什么是流水线

在工业上，流水线被广泛应用在装配线上。

举例来说，老王有一个生产洋娃娃的工厂，一个洋娃娃的生产流程分为4个步骤：1.制作躯干；2.缝上眼睛和嘴巴；3.添加头发；4.包装。

在流水线化之前，每个娃娃必须完成这4个工序才能开始制作下一个娃娃。如果每个步骤需要的时间是1个小时的话，那么每4个小时才能生产1个洋娃娃。

后来人们发现了一个更加有效的方法，即使用流水线。虽然制作一个洋娃仍然需要4个步骤，但是不需要从头到尾全部完成，而是每个步骤由专人来完成，所有步骤并行进行。也即工序1完成躯干的任务并转交给工序2时，工序1的工人又开始下一个洋娃娃的制作了。

使用流水线的好处在于，可以提高单位时间的生产量。图2.1显示了使用流水线前后生产效率的变化。

![图2.1 使用流水线前后生产效率的变化](images/chapter02_compare_pipeline.png)

可以发现，流水线系统中决定最后生产速度的是最慢的工序所需的时间。例如，如果产生洋娃娃的第2道工序需要的是两个小时，其他工序仍然需要1个小时的话，那么平均每两个小时才能生产出一个洋娃娃。即工序2是性能瓶颈（bottleneck）。

理想情况下，如果把一个非流水线系统分成n个流水线阶段，且每个阶段耗费时间相同的话，会使整个系统得到n倍的速度提升。

### 2.1.2 什么是渲染流水线

上面关于流水线的概念同样适用于计算机的图像渲染中。渲染流水线的工作任务在于由一个三维场景出发、生成一张二维图像。换句话说，计算机需要从一系列的顶点数据、纹理等信息出发，把这些信息最终转换成一张人眼可以看到的图像。而这个工作通常是由CPU和GPU共同完成的。

《Real-Time Rendering, third edition》一书中将一个渲染流程分成3个阶段：应用阶段（Application stage）、几何阶段（Geometry stage）、光栅化阶段（Rasterizer stage）。

每个阶段本身通常也是一个流水线系统，即包含了子流水线阶段。见下图。

![图2.2 渲染流水线中的3个概念阶段](images/chapter02_three_stage_in_rendering.png)

- 应用阶段

这个阶段是我们的应用主导的。通常由CPU负责实现。换句话说，应用开发者在这个阶段有绝对控制权。

在这个阶段，主要有3个任务：1. 准备好场景数据，例如摄像机的位置、视锥体、场景中包含了哪些模型、使用了哪些光源等；2. 为了提高渲染性能，需要做一个粗粒度剔除（culling）工作，把那些不可见的物体剔除出去；3. 设置每个模型的渲染状态。包括模型使用的材质、纹理、shader等。

这个阶段输出的是渲染所需的几何信息，即渲染图元（rendering primitives）。渲染图元可以是点、线、三角面等。

- 几何阶段

这一阶段通常在GPU上执行。

几何阶段负责和每个渲染图元打交道，进行逐顶点、逐多边形的操作。

几何阶段的一个重要任务就是把顶点坐标变换到屏幕空间中，再交给光栅器处理。

这一阶段的输出是屏幕空间的二维顶点坐标、每个顶点对应的深度值、着色等信息。

- 光栅化阶段

这一阶段产生屏幕上的像素，渲染出最终的图像。该阶段在GPU上执行。光栅化决定渲染图元中的哪些像素应该被绘制在屏幕上。它对输入的逐顶点数据（纹理坐标、顶点颜色等）进行插值，然后再进行逐像素处理。

## CPU和GPU之间的通信

应用阶段分为下面3个阶段：

1. 把数据加载到显存中；
2. 设置渲染状态；
3. 调用Draw Call；

### 2.2.1 把数据加载到显存中

渲染所需的数据需要从硬盘（Hard disk drive，HDD）中加载到系统内存（random access memory, RAM)中，然后网格和纹理等数据被加载到显卡上的存储空间——显存（video random access memory，VRAM）中。这是因为，显卡对于显存的访问速度更快，而且大多数显卡对于RAM没有直接的访问权利。见下图。

![图2.3 渲染所需的数据（2张纹理以及3个网格）从硬盘最终加载到显存中。在渲染时，GPU可以快速访问这些数据。](images/chapter02_load_data_from_disk_to_vram.png)

当把数据加载到显存中后，RAM中的数据就可以移除了。但对于一些数据来说，CPU仍然需要访问它们。比如CPU使用网格数据来进行碰撞检测，这时就不希望这些数据被移除，因为从硬盘加载到RAM的过程十分耗时。

### 2.2.2 设置渲染状态

状态定义了场景中的网格是怎样被渲染的。包括顶点着色（vertex shader）、片元着色器（fragment shader）、光源属性、材质等。
